# ğŸ§  LeetCode Daily Solution  
## 3651. Minimum Cost Path with Teleportations (Hard)

### ğŸ‘¤ Author
**Ravi Ranjan**  
Daily LeetCode Practice ğŸš€

---

## ğŸ“Œ Problem Overview

You are given an `m x n` grid where each cell contains a non-negative cost.  
You start at the **top-left cell `(0, 0)`** and want to reach the **bottom-right cell `(m-1, n-1)`** with **minimum total cost**.

### Allowed Moves

1. **Normal Move**
   - Move **Right** or **Down**
   - Cost = value of the destination cell

2. **Teleportation**
   - From `(i, j)` you can teleport to **any cell `(x, y)`**
   - Condition: `grid[x][y] <= grid[i][j]`
   - Cost = `0`
   - Can be used **at most `k` times**

---

## ğŸ§© Key Observations

- Normal moves form a **DAG** (only right & down).
- Teleportation allows **jumping anywhere** but only to cells with **less or equal value**.
- Since teleportation is limited (`k â‰¤ 10`), we can use **DP layers**.
- Grid size is up to `80 x 80` â†’ brute force teleport edges are impossible.
- We must **batch teleport transitions efficiently**.

---

## ğŸ’¡ Intuition

Think of the solution as **layers of DP**:

- Each layer represents using `t` teleportations.
- Inside a layer:
  - First, relax all **normal moves** (right & down).
  - Then apply **one teleport** by propagating the minimum cost to all valid lower/equal-value cells.

Teleportation is optimized by:
- Grouping cells by value
- Processing them in **descending order**
- Maintaining a prefix minimum

---

## ğŸ› ï¸ Approach

1. Convert the grid into a 1D index system.
2. Maintain `dp[t][cell]` â†’ minimum cost to reach `cell` using `t` teleports.
3. For each teleport count:
   - Run DP for normal moves.
   - Apply teleport transition using value-based grouping.
4. Track the minimum cost to reach the destination.

---

## â±ï¸ Complexity Analysis

- **Time Complexity:**  
  \[
  O(k \cdot m \cdot n)
  \]
  (Teleport layers Ã— grid traversal)

- **Space Complexity:**  
  \[
  O(m \cdot n)
  \]
  (DP arrays)

---

## âœ… Example

**Input**
grid = [[1,3,3],
[2,5,4],
[4,3,5]]
k = 2


**Output**
7


Teleporting at the right moment avoids expensive paths.

---

## ğŸ§ª Solution Code (C++)

```cpp
class Solution {
public:
    int minCost(vector<vector<int>>& grid, int k) {
        int m = grid.size(), n = grid[0].size();
        const long long INF = (1LL << 60);
        int N = m * n;

        auto id = [&](int i, int j) { return i * n + j; };

        vector<pair<int,int>> cells;
        for(int i = 0; i < m; i++)
            for(int j = 0; j < n; j++)
                cells.push_back({grid[i][j], id(i,j)});

        sort(cells.begin(), cells.end());

        vector<vector<int>> groups;
        for(int i = 0; i < N;) {
            int v = cells[i].first;
            vector<int> g;
            while(i < N && cells[i].first == v) {
                g.push_back(cells[i].second);
                i++;
            }
            groups.push_back(g);
        }
        reverse(groups.begin(), groups.end());

        auto relax = [&](vector<long long> dp) {
            for(int i = 0; i < m; i++) {
                for(int j = 0; j < n; j++) {
                    long long cur = dp[id(i,j)];
                    if(cur >= INF) continue;
                    if(j + 1 < n)
                        dp[id(i,j+1)] = min(dp[id(i,j+1)], cur + grid[i][j+1]);
                    if(i + 1 < m)
                        dp[id(i+1,j)] = min(dp[id(i+1,j)], cur + grid[i+1][j]);
                }
            }
            return dp;
        };

        vector<long long> cur(N, INF);
        cur[0] = 0;
        long long ans = INF;

        for(int used = 0; used <= k; used++) {
            auto after = relax(cur);
            ans = min(ans, after[id(m-1,n-1)]);
            if(used == k) break;

            vector<long long> next(N, INF);
            long long prefMin = INF;
            for(auto& g : groups) {
                for(int idx : g) prefMin = min(prefMin, after[idx]);
                for(int idx : g) next[idx] = prefMin;
            }
            cur.swap(next);
        }

        return ans >= INF ? -1 : (int)ans;
    }
};
ğŸ Status
âœ… Accepted
ğŸ”¥ Daily LeetCode Hard Solved
ğŸ“ˆ Streak Continues

ğŸ“ Tags
Dynamic Programming Graph Optimization Teleportation Hard
